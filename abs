#!/bin/bash
#
# ABS Backup System
# Copyright (C) 2011 SitePoint Pty Ltd
#
# Contact details provided at http://www.sitepoint.com/
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


## Variables
#

declare -r backupNameDefault="daily"
declare -r backupCfg="/usr/local/etc/abs.conf"
declare -r lockFile="/var/run/backups.pid"

# There should be no reason to touch anything below this line.
declare -r scriptName="$(basename ${0})"
declare -i verbose=0
declare backupName


## Functions
#

function doSafetyChecks()
{
    # Check we're running as root.
    if [ "${UID}" -ne 0 ]
    then
        printError "Must be run as root."
        exit 1
    fi

    # Check the config file exists.
    if [ ! -f "${backupCfg}" ]
    then
        printError "Configuration file not found."
        exit 1
    fi

    # Set a default backup name if required.
    if [ -z "${backupName}" ]
    then
        backupName="${backupNameDefault}"
    fi

    # Ignore comments, condense whitespace, and then verify that the
    # requested backup has entries in the configuration file.
    sed -e 's/#.*$//;s/[[:space:]]\+/\ /g' "${backupCfg}" | \
        grep -q "[[:space:]]\+${backupName}[[:space:]]*$"
    if [ "${?}" -ne 0 ]
    then
        printError "No entries for '${backupName}' in file '${backupCfg}'."
        exit 1
    fi
}

function setLockFile()
{
    declare cmdAtPID

    # If the lockfile exists
    if [ -f "${lockFile}" ]
    then
        # If the lockfile points to a process by the same name
        cmdAtPID="$(ps -p $(cat "${lockFile}") -o comm=)"
        echo "${cmdAtPID}" | grep -q "^${scriptName}$"
        if [ "${?}" -eq 0 ]
        then
            # Wait 10 minutes and try again.
            echo "Sleeping, waiting for the lock to free up."
            sleep 600
            setLockFile
        else
            # Old lock file. Overwrite it.
            echo ${$} > "${lockFile}"
        fi
    else
        echo ${$} > "${lockFile}"
    fi
}

function delLockFile()
{
    rm -f "${lockFile}"
}

function checkIsSource()
{
    declare -r variable="${1}"
    declare -r variableLine="${2}"
    declare hostName
    declare pathName

    hostName="$(echo ${variable} | cut -d ':' -f 1)"
    pathName="$(echo ${variable} | cut -d ':' -f 2)"

    checkIsHost ${hostName} ${variableLine}
    checkIsPath ${pathName} ${variableLine} 0 || \
        return 1
}

function checkIsPath()
{
    declare -r variable="${1}"
    declare -r variableLine="${2}"
    declare -ri checkPath="${3}"  # Check if it exists locally?

    echo "${variable}" | grep -q '^\/.*$' || \
        {
            echo -n "Warning: '${variable}' is not an absolute "
            echo "path on line ${variableLine} of file '${backupCfg}'."
            return 1
        }

    if [ "${checkPath}" -eq 1 -a ! -d "${variable}" ]
    then
        echo -n "Warning: '${variable}' (referenced on line "
        echo "${variableLine} of file '${backupCfg}') does not exist!"
        return 1
    fi
}

function checkIsInt()
{
    declare -r variable="${1}"
    declare -r variableLine="${2}"

    echo "${variable}" | grep -q '^[[:digit:]]*$' || \
        {
            echo -n "Warning: '${variable}' is not an integer on "
            echo "line ${variableLine} of file '${backupCfg}'."
            return 1
        }
}

# Not certain there is any benefit to this check as currently used.
function checkIsAlnum()
{
    declare -r backup="${1}"
    declare -r lineNum="${2}"

    echo "${backup}" | grep -q '^[[:alnum:]_-]*$' || \
        {
            echo -n "Warning: '${backup}' is not a valid name on "
            echo "line ${lineNum} of file '${backupCfg}'."
            return 1
        }
}

function checkIsHost()
{
    declare -r hostName="${1}"
    declare -r variableLine="${2}"

    ping -c 1 ${hostName} >/dev/null
    if [ "${?}" -ne 0 ]
    then
        echo -n "Warning: Cannot ping host '${hostName}', "
        echo -n "referenced on line ${variableLine} of file "
        echo -e "'${backupCfg}'.\nWe may fail at running rsync later."
    fi
}

function findLastGoodBackup()
{
    declare -r local_path="${1}"
    declare -r backup_name="${2}"

    for backup in $(find "${local_path}" -mindepth 1 -maxdepth 1 \
        -type d -name 'daily.*' | sort -V)
    do
        if [ ! -f "${backup}.incomplete" ]
        then
            echo "${backup:${#backup}-1}"
            return 0
        fi
    done

    # We didn't find anything.
    echo 0
}

function rsyncCmd()
{
    function rsyncFailMsg()
    {
        {
            echo -n "Warning: Rsync from "
            echo -n "root@${rmtHostName}:${rmtPathName} "
            echo "failed."
        } >&2
    }

    declare -r rmtHostName="${1}"
    declare -r rmtPathName="${2}"
    declare -r local_path="${3}"
    declare -r backup_name="${4}"
    declare -r local_backup_dir="${3}/${4}"
    declare -i rsyncFail=0
    declare -r rsyncExclude="--exclude=/dev/*
        --exclude=/home/*/.gvfs
        --exclude=/lost+found/*
        --exclude=/proc/*
        --exclude=/sys/*
        --exclude=/tmp/*
        --exclude=/srv/chroot/wheezy/dev/*
        --exclude=/srv/chroot/wheezy/proc/*
        --exclude=/srv/chroot/wheezy/sys/*
        --exclude=/srv/chroot/wheezy/tmp/*"
    declare cmdWrap=""
    declare -i last_good=0

    # Used by the bash time command.
    TIMEFORMAT=$'\nreal\t%3lR\nuser\t%3lU\nsys\t%3lS'

    [ "${verbose}" -ne 0 ] && cmdWrap="time"
    printSrcDst "${rmtHostName}:${rmtPathName}" "${local_backup_dir}.0"
    touch "${local_backup_dir}.0.incomplete"
    last_good="$(findLastGoodBackup "${local_path}" "${backup_name}")"

    # We use eval so the bash (semi-)builtin command takes precedence
    # when the time package/comamnd is installed.
    eval ${cmdWrap} rsync -a -e ssh --delete \
        $([ "${rmtPathName}" = "/" ] && echo ${rsyncExclude}) \
        $([ "${last_good}" -ne 0 ] && \
            echo --link-dest=${local_backup_dir}.${last_good}) \
        root@${rmtHostName}:${rmtPathName} \
        "${local_backup_dir}.0" && \
            rm -f "${local_backup_dir}.0.incomplete" || rsyncFail=1

    if [ "${rsyncFail}" -ne 0 ]
    then
        rsyncFailMsg
    fi

    # Formatting improvements
    if [ "${verbose}" -ne 0 ]
    then
        echo -e '\n'
    fi
}

function syncFiles()
{
    declare -r source_path="${1}"
    declare -r local_path="${2}"
    declare -i keep="${3}"
    declare -r backup_name="${4}"
    declare -r rmtHostName="$(echo ${source_path} | cut -d ':' -f 1)"
    declare -r rmtPathName="$(echo ${source_path} | cut -d ':' -f 2)"
    declare snapshotNum
    declare -i rsyncFail=0
    declare cmdWrap=""

    # Unlike the config file, we count from 0. Subtract 1.
    (( keep-- ))

    for snapshotNum in $(seq ${keep} -1 0)
    do
        if [ "${snapshotNum}" -eq "${keep}" ]
        then
            # Delete the oldest snapshot
            rm -rf "${local_path}/${backup_name}.${snapshotNum}"{,.incomplete}
        else
            # Increment the snapshot number of all other exiting snapshots.
            if [ -d "${local_path}/${backup_name}.${snapshotNum}" ]
            then
                mv "${local_path}/${backup_name}.${snapshotNum}" \
                    "${local_path}/${backup_name}.$(( snapshotNum + 1 ))"
            fi
            # Don't forget to increment any '.incomplete' notices also.
            if [ -f "${local_path}/${backup_name}.${snapshotNum}.incomplete" ]
            then
                mv "${local_path}/${backup_name}.${snapshotNum}.incomplete" \
                    "${local_path}/${backup_name}.$(( snapshotNum + 1 )).incomplete"
            fi
        fi

        if [ "${snapshotNum}" -eq 0 ]
        then
            if [ "${backupNameDefault}" = "${backup_name}" ]
            then
                rsyncCmd "${rmtHostName}" "${rmtPathName}" \
                    "${local_path}" "${backup_name}"
            else
                # Just grab the latest default backup.
                last_good="$(findLastGoodBackup "${local_path}" \
                    "${backupNameDefault}")"

                printSrcDst "${local_path}/${backupNameDefault}.${last_good}" \
                    "${local_path}/${backup_name}.0"
                touch "${local_path}/${backup_name}.0.incomplete"
                [ "${verbose}" -ne 0 ] && cmdWrap="time"

                eval ${cmdWrap} cp -al "${local_path}/${backupNameDefault}.${last_good}" \
                    "${local_path}/${backup_name}.0" && \
                    rm -f "${local_path}/${backup_name}.0.incomplete" || \
                    printWarning \
                        "Problem detected creating backup '${backup_name}.0'."

                # Formatting improvements
                if [ "${verbose}" -ne 0 ]
                then
                    echo -e '\n'
                fi
            fi
        fi
    done
}

function doBackup()
{
    declare source_path
    declare local_path
    declare keep
    declare backup_name
    declare -i lineNum=0
    declare variable
    declare -r oldIFS="${IFS}"

    IFS=$'\n'

    while read line
    do
        (( lineNum++ ))

        # Ignore comments.
        line="$(echo "${line}" | sed -e 's/#.*$//')"

        # Ignore empty lines (including lines with only whitespace).
        [ -z "$(echo "${line}" | sed -e 's/[[:space:]]*//g')" ] && continue

        source_path="$(echo "${line}" | cut -d ' ' -f 1)"
        local_path="$(echo "${line}" | cut -d ' ' -f 2)"
        keep="$(echo "${line}" | cut -d ' ' -f 3)"
        backup_name="$(echo "${line}" | cut -d ' ' -f 4)"

        # Check config file lines look valid.
        checkIsSource ${source_path} ${lineNum} && \
            checkIsPath ${local_path} ${lineNum} 1 && \
            checkIsInt ${keep} ${lineNum} && \
            checkIsAlnum ${backup_name} ${lineNum} || \
            {
                # If this was a backup we originally intended to do but are now
                # skipping, indicate as such.
                if [ "${backupName}" = "${backup_name}" ]
                then
                    printWarning \
                        "Skipping backup specified on line ${lineNum}."
                fi
                continue
            }

        if [ "${backupName}" = "${backup_name}" ]
        then
            syncFiles ${source_path} ${local_path} ${keep} \
                ${backup_name}
        fi

    # When reading in the file, reduce any whitespace to a single space.
    done < <(sed -e 's/[[:space:]]\+/\ /g' ${backupCfg})

    IFS="${oldIFS}"
}

function printUsage()
{
    echo "Usage: ${0} [OPTIONS] [BACKUP]"
    echo
    echo "where:"
    echo
    echo "OPTIONS:"
    echo "-h      print help"
    echo "-v      be verbose"
    echo
    echo "BACKUP:"
    echo "Can be anything specified in ${backupCfg}"
    echo "(defaults to 'daily')."
    echo
    echo "eg."
    echo "# ${0} -v daily"
}

function printSrcDst()
{
    echo "${1} -> ${2}"
}

function printWarning()
{
    echo "Warning: ${@}" 1>&2
}

function printError()
{
    echo "Error: ${@}" 1>&2
}

function printArgError
{
    printError "Unknown option '${@}'."
}

function getOpts()
{
    declare option
    declare -i failure=0
    declare -i help=0

    while getopts ":vh" option
    do
        case ${option} in
            h )
                [ "${help}" -ne 1 ] && help=1
                ;;
            v )
                [ "${verbose}" -ne 1 ] && verbose=1
                ;;
            * )
                {
                    printArgError ${OPTARG}
                    failure=1
                } >&2
                ;;
        esac
    done
    shift $(($OPTIND - 1))

    backupName="${1}"
    shift

    if [ -n "${*}" ]
    then
        printArgError ${@}
        failure=1
    fi

    if [ "${failure}" -ne 0 ]
    then
        echo -e "Aborting.\n"
        printUsage
        exit "${failure}" 
    fi

    [ "${help}" -ne 0 ] && { printUsage ; exit 0 ; }
    [ "${verbose}" -ne 0 ] && echo -e "Verbose mode activated.\n"
}


## Begin execution
#

getOpts ${@}
doSafetyChecks
setLockFile
doBackup
delLockFile

# EOF
